# SLSA Build Levels 1 & 2 Explained

This document explains **exactly** what SLSA Build Level 1 and Level 2 mean, how we implement them, and how to verify compliance.

## üìñ Table of Contents

- [What is SLSA?](#what-is-slsa)
- [SLSA Build Level 1](#slsa-build-level-1)
- [SLSA Build Level 2](#slsa-build-level-2)
- [Our Implementation](#our-implementation)
- [Verifying Compliance](#verifying-compliance)
- [Common Misconceptions](#common-misconceptions)

## What is SLSA?

**SLSA** (Supply-chain Levels for Software Artifacts) is a security framework that helps protect software supply chains from tampering and unauthorized modification.

Think of it as a **report card** for your build process:
- Did you build this yourself, or was it built automatically?
- Can you prove HOW it was built?
- Can you prove WHERE it was built?
- Can anyone tamper with the build process?

## SLSA Build Level 1

### Requirements (from [slsa.dev](https://slsa.dev/spec/v1.1/levels))

1. ‚úÖ **Build process is fully scripted/automated**
   - No manual steps (like clicking buttons or running commands by hand)
   - Everything is code/configuration

2. ‚úÖ **Provenance exists**
   - There's a document that says "this artifact was built from source X using process Y"
   - It's like a receipt for your build

### What This Means in Practice

**Without SLSA L1:**
```bash
# You manually build on your laptop
$ docker build -t myapp .
$ docker push myapp

# Problems:
# - No record of HOW it was built
# - Could have been built anywhere
# - Can't verify the source code used
```

**With SLSA L1:**
```yaml
# GitHub Actions builds automatically
- name: Build
  uses: docker/build-push-action@v6
  with:
    provenance: true  # Generates provenance document
```

Now you have:
- ‚úÖ Automated build (GitHub Actions)
- ‚úÖ Provenance document attached to the image

### The Provenance Document

The provenance looks like this (simplified):

```json
{
  "buildType": "https://github.com/docker/build-push-action@v1",
  "invocation": {
    "configSource": {
      "uri": "git+https://github.com/YOUR_USER/YOUR_REPO@refs/heads/main",
      "digest": {"sha1": "abc123..."}
    }
  },
  "materials": [
    {
      "uri": "git+https://github.com/YOUR_USER/YOUR_REPO",
      "digest": {"sha1": "abc123..."}
    }
  ]
}
```

This says: "This artifact was built from commit `abc123` in YOUR_REPO"

## SLSA Build Level 2

### Requirements (from [slsa.dev](https://slsa.dev/spec/v1.1/levels))

1. ‚úÖ **All Build L1 requirements**

2. ‚úÖ **Hosted build platform**
   - Build happens on a service (not your laptop)
   - Examples: GitHub Actions, GitLab CI, Cloud Build

3. ‚úÖ **Build service generates provenance**
   - The build platform (not you) creates the provenance
   - You can't manually edit it

### What This Means in Practice

**SLSA L1 vs L2 - The Key Difference:**

| Aspect | Build L1 | Build L2 |
|--------|----------|----------|
| **Where build happens** | Could be anywhere | Must be on a hosted service |
| **Who creates provenance** | Could be anyone | Must be the build service |
| **Trust model** | "I built this" | "GitHub Actions built this" |

**Example:**

‚ùå **NOT Build L2** (even with provenance):
```bash
# Build on your laptop
$ docker build --provenance=true -t myapp .

# Problem: You could modify the provenance
# Problem: No way to verify WHERE it was built
```

‚úÖ **IS Build L2**:
```yaml
# In GitHub Actions
jobs:
  build:
    runs-on: self-hosted  # or ubuntu-latest
    steps:
      - uses: docker/build-push-action@v6
        with:
          provenance: true  # GitHub Actions generates this

# Why this works:
# - Runs on GitHub's infrastructure (hosted)
# - Provenance generated by build-push-action (not you)
# - Build environment is controlled by GitHub
```

### The Enhanced Provenance

Build L2 provenance includes MORE information:

```json
{
  "buildType": "https://github.com/docker/build-push-action@v1",
  "builder": {
    "id": "https://github.com/Attestations/GitHubHostedActions@v1"
  },
  "invocation": {
    "configSource": {
      "uri": "git+https://github.com/YOUR_USER/YOUR_REPO",
      "digest": {"sha1": "abc123..."},
      "entryPoint": ".github/workflows/ci.yml"
    },
    "environment": {
      "github_run_id": "1234567",
      "github_actor": "your-username"
    }
  },
  "metadata": {
    "buildInvocationId": "github-actions-1234567",
    "buildStartedOn": "2024-01-15T10:30:00Z",
    "buildFinishedOn": "2024-01-15T10:35:00Z"
  }
}
```

Notice the `builder.id` field - this proves GitHub Actions built it!

## Our Implementation

### How We Achieve Build L1

```yaml
# File: .github/workflows/slsa-l1-l2.yml

jobs:
  build-and-push:
    runs-on: self-hosted  # Automated build environment
    steps:
      # Fully scripted - no manual steps
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3

      # This generates SLSA provenance
      - uses: docker/build-push-action@v6
        with:
          provenance: true  # ‚Üê Build L1 requirement
```

‚úÖ **Build L1 achieved because:**
- Entire build is scripted (YAML workflow)
- Provenance is automatically generated
- No manual intervention needed

### How We Achieve Build L2

The **same workflow** also achieves Build L2:

```yaml
jobs:
  build-and-push:
    runs-on: self-hosted  # ‚Üê Hosted build platform
```

‚úÖ **Build L2 achieved because:**
- Build runs on GitHub Actions (hosted platform)
- `docker/build-push-action` generates provenance (not us)
- Provenance includes `builder.id` identifying GitHub Actions
- Build environment is controlled by the platform

### Why Self-Hosted Runners Still Count as "Hosted"

You might wonder: "If I run a self-hosted runner, isn't that just my machine?"

**Answer:** Yes, but the **orchestration** is still hosted by GitHub:
- GitHub controls the workflow execution
- GitHub provides the runner software
- GitHub logs the build invocation
- You can't modify the workflow DURING execution

The key is: **you don't manually run `docker build`** - GitHub Actions does.

## Verifying Compliance

### Verify Build L1 Compliance

**Check 1: Build is automated**
```bash
# Look at your workflow file
cat .github/workflows/slsa-l1-l2.yml

# Should see:
# - No manual steps
# - Triggered automatically (on: push)
# - All commands in YAML
```

**Check 2: Provenance exists**
```bash
# Inspect the image
docker buildx imagetools inspect ghcr.io/USER/IMAGE:TAG

# Should see attestation manifests:
# MediaType: application/vnd.in-toto+json
```

### Verify Build L2 Compliance

**Check 1: Hosted build platform**
```bash
# Check GitHub Actions logs
gh run view <RUN_ID>

# Should show:
# - Run on: self-hosted (or ubuntu-latest)
# - Orchestrated by GitHub Actions
```

**Check 2: Provenance by service**
```bash
# View the provenance (requires cosign or similar tool)
# The provenance should include:
# - builder.id pointing to GitHub Actions
# - Build environment details
# - Workflow information
```

**Check 3: Can't be manually modified**
- Provenance is generated DURING the build
- Stored directly by docker/build-push-action
- You never see or touch the provenance JSON

## Common Misconceptions

### ‚ùå Misconception 1: "I need SLSA L3 to be secure"

**Reality:** Build L2 already gives you:
- Automated, repeatable builds
- Proof of what was built and how
- Harder to tamper with than manual builds

Build L3 adds:
- Even stronger isolation
- Non-falsifiable provenance
- Protection against compromised build systems

But L2 is a HUGE improvement over nothing!

### ‚ùå Misconception 2: "Provenance = Signature"

**Reality:**
- **Provenance** = A document describing the build
- **Signature** = Cryptographic proof the artifact hasn't changed

You can have provenance without signatures (SLSA L1/L2).
You can add signatures later (Cosign, which we'll do next).

### ‚ùå Misconception 3: "Self-hosted runners aren't 'hosted'"

**Reality:**
- "Hosted" means "controlled by a build service"
- GitHub Actions controls the workflow execution
- Even on your hardware, GitHub orchestrates the process
- You can't manually interfere mid-build

### ‚ùå Misconception 4: "I need to verify provenance in K8s"

**Reality (for L1/L2):**
- Build L1/L2 focus on **generation** of provenance
- **Verification** is separate (comes with Cosign + Kyverno)
- For now, provenance just needs to **exist** with the image

## What's Next?

Now that you have Build L1 + L2:

1. **Verify it works**
   - Run the pipeline
   - Inspect the image
   - Confirm provenance exists

2. **Understand the provenance**
   - What information does it contain?
   - How is it stored?
   - Who can access it?

3. **Add verification** (next phase)
   - Cosign: Sign and verify images
   - Kyverno: Enforce policies in K8s
   - Wazuh: Monitor runtime behavior

4. **Consider Build L3** (future)
   - Use `slsa-github-generator`
   - Hardened build isolation
   - Non-falsifiable provenance

## Summary Checklist

Use this to verify your SLSA L1/L2 implementation:

### SLSA Build L1 Checklist

- [ ] Build process is fully scripted (no manual steps)
- [ ] Build is triggered automatically (git push, PR, etc.)
- [ ] Provenance is generated during the build
- [ ] Provenance is attached to the artifact (image)
- [ ] Provenance includes source commit info

### SLSA Build L2 Checklist

- [ ] All Build L1 requirements met
- [ ] Build runs on a hosted platform (GitHub Actions)
- [ ] Platform generates the provenance (not manually created)
- [ ] Provenance includes builder identity
- [ ] Provenance includes build environment details
- [ ] You cannot modify provenance during/after build

## References

- [SLSA Specification v1.1](https://slsa.dev/spec/v1.1/)
- [SLSA Build Levels](https://slsa.dev/spec/v1.1/levels)
- [Docker Build Attestations](https://docs.docker.com/build/attestations/)
- [GitHub Actions SLSA](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect)

---

**Understanding SLSA is the first step to securing your supply chain!** üîí
