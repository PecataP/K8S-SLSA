# SLSA L3 Complete Explanation - For Beginners

This guide explains **everything** about SLSA Level 3 implementation, assuming you're seeing this for the first time. We'll break down every concept, every tool, and every file.

---

## Table of Contents

1. [What Problem Are We Solving?](#what-problem-are-we-solving)
2. [Core Concepts Explained](#core-concepts-explained)
3. [The Big Picture: How Everything Fits Together](#the-big-picture-how-everything-fits-together)
4. [Deep Dive: Each Component](#deep-dive-each-component)
5. [File-by-File Explanation](#file-by-file-explanation)
6. [Step-by-Step Flow](#step-by-step-flow)
7. [Common Questions](#common-questions)

---

## What Problem Are We Solving?

### The Security Problem

Imagine this scenario:

1. You write code and push it to GitHub
2. CI/CD builds a container image
3. The image is deployed to Kubernetes
4. **Problem**: How do you know the running container is actually YOUR code?

**Potential attacks**:
- Someone compromises your CI/CD and injects malicious code
- Someone replaces your image in the registry with a backdoored version
- Someone overwrites the `:latest` tag with malicious code
- Your build process is tampered with

### The SLSA Solution

**SLSA** (Supply-chain Levels for Software Artifacts) is a framework that provides **provable guarantees** about your software:

- **Where** it was built (which system)
- **How** it was built (what steps)
- **What** was used to build it (source code, dependencies)
- **Who** authorized the build (which workflow, commit)

SLSA has 4 levels, each adding more security:

| Level | What It Provides |
|-------|------------------|
| **L1** | Provenance exists (metadata about the build) |
| **L2** | Provenance is generated by a trusted service (not you) |
| **L3** | Provenance is non-falsifiable (hardened builds + signing) |
| **L4** | Two-person review + hermetic builds |

**We're implementing L3**, which gives you cryptographic proof that:
1. Your code was built in an isolated, secure environment
2. The build process wasn't tampered with
3. The resulting image matches what was actually built
4. Only verified images can be deployed to your cluster

---

## Core Concepts Explained

Let's explain each technology and concept we're using:

### 1. Container Image Digests

**What is it?**

A digest is a **unique cryptographic fingerprint** of a container image.

**Example**:
```
Tag:    ghcr.io/pecatap/python-slsa-web:latest
Digest: ghcr.io/pecatap/python-slsa-web@sha256:a1b2c3d4e5f6...
```

**Why does it matter?**

- **Tags are mutable**: Someone can overwrite `:latest` with different content
- **Digests are immutable**: The sha256 hash uniquely identifies the exact image
- If even 1 byte changes, you get a completely different digest

**Analogy**:
- Tag = "Most Recent Document.docx" (can be replaced)
- Digest = "Document-final-v3-2024-01-15-3pm.docx" (unique and specific)

**Why we use it for SLSA L3**:
- Prevents "tag mutation attacks"
- Ensures you deploy exactly what was built
- Required for verifying signatures and provenance

---

### 2. Cosign (Container Signing)

**What is it?**

Cosign is a tool from **Sigstore** that signs container images and verifies those signatures.

**How it works**:

```
┌─────────────────────────────────────────┐
│  1. Build Image                         │
│     ghcr.io/app@sha256:abc123           │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│  2. Cosign Signs Image                  │
│     Creates a cryptographic signature   │
│     Signs with: GitHub Actions identity │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│  3. Signature Stored in Registry        │
│     As OCI artifact attached to image   │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│  4. Verification (Later)                │
│     Cosign verifies signature is valid  │
│     Checks it came from authorized      │
│     GitHub Actions workflow             │
└─────────────────────────────────────────┘
```

**Key Innovation: Keyless Signing**

Old way (with keys):
- Generate private/public key pair
- Store private key securely (hard!)
- Sign with private key
- Verify with public key

New way (keyless with OIDC):
- GitHub Actions has an **identity** (OIDC token)
- Cosign uses this identity to sign
- Identity is: "This workflow in this repository on this commit"
- No keys to manage!

**What gets signed?**
```json
{
  "image": "ghcr.io/pecatap/python-slsa-web@sha256:abc123",
  "identity": "https://github.com/PecataP/K8S-SLSA/.github/workflows/slsa-l3.yml@refs/heads/main",
  "issuer": "https://token.actions.githubusercontent.com",
  "timestamp": "2024-01-15T10:30:00Z"
}
```

**Why we use it**:
- Proves the image came from YOUR GitHub Actions workflow
- Prevents unauthorized images from being deployed
- No keys to manage or protect

---

### 3. SLSA Provenance

**What is it?**

Provenance is a **signed document** that describes how an artifact (container image) was built.

**Think of it as a "birth certificate" for your container image.**

**What it contains**:

```json
{
  "builder": {
    "id": "https://github.com/slsa-framework/slsa-github-generator/..."
  },
  "buildType": "https://slsa.dev/container-based-build/v0.1",
  "invocation": {
    "configSource": {
      "repository": "https://github.com/PecataP/K8S-SLSA",
      "ref": "refs/heads/main",
      "commit": "a1b2c3d4e5f6..."
    }
  },
  "materials": [
    {
      "uri": "git+https://github.com/PecataP/K8S-SLSA@a1b2c3...",
      "digest": {"sha1": "a1b2c3d4e5f6..."}
    },
    {
      "uri": "pkg:docker/python@3.11-alpine",
      "digest": {"sha256": "x1y2z3..."}
    }
  ],
  "metadata": {
    "buildStartedOn": "2024-01-15T10:00:00Z",
    "buildFinishedOn": "2024-01-15T10:05:00Z"
  }
}
```

**What this tells us**:
1. **Builder**: Who built it (slsa-github-generator, not you directly)
2. **Source**: What code was used (repository, commit SHA)
3. **Materials**: All inputs (source code, base images, dependencies)
4. **Process**: How it was built (buildType, steps)
5. **Environment**: Where it was built (GitHub Actions)

**Why it matters**:

- **L1**: "Provenance exists" → We have this metadata
- **L2**: "Generated by service" → GitHub Actions generates it
- **L3**: "Non-falsifiable" → Generated by slsa-github-generator in isolated environment

**L2 vs L3 Provenance**:

| Aspect | L2 Provenance | L3 Provenance |
|--------|---------------|---------------|
| Generated by | `docker/build-push-action` | `slsa-github-generator` |
| Can you modify it? | Yes (user-controlled) | No (service-controlled) |
| Isolation | No guarantee | Hardened, isolated build |
| Trust level | Medium | High |

---

### 4. slsa-github-generator

**What is it?**

A **reusable GitHub Actions workflow** maintained by the SLSA team that generates **SLSA L3 provenance**.

**Why do we need it?**

If you generate your own provenance, you could lie:
```yaml
# Bad: User-controlled (L2 at best)
- name: Generate provenance
  run: |
    echo '{"builder": "trusted-system"}' > provenance.json
    # But this is fake! You wrote it yourself!
```

**slsa-github-generator** solves this:
- Runs in a **separate, isolated job**
- You call it, but you **don't control** what it does
- It generates provenance based on **observed facts**
- Cryptographically signed by the generator itself

**How it works**:

```
┌─────────────────────────────────────────────────┐
│  Your Workflow (Job 1: build-and-push)          │
│  - Builds image                                 │
│  - Pushes to registry                           │
│  - Outputs: image digest                        │
└──────────────────┬──────────────────────────────┘
                   │
                   │ digest passed to next job
                   │
                   ▼
┌─────────────────────────────────────────────────┐
│  slsa-github-generator (Job 2: provenance)      │
│  - Runs in isolated environment                 │
│  - YOU DON'T CONTROL THIS JOB                   │
│  - It inspects the build from outside           │
│  - Generates signed provenance                  │
│  - Attaches provenance to your image            │
└─────────────────────────────────────────────────┘
```

**Key point**: Because you don't control the provenance generation, it's **non-falsifiable** (L3 requirement).

---

### 5. Kyverno

**What is it?**

Kyverno is a **Kubernetes policy engine** that runs as an **admission controller**.

**What's an admission controller?**

Before any resource (Pod, Deployment, etc.) is created in Kubernetes, admission controllers can:
1. **Validate** it (check if it meets requirements)
2. **Mutate** it (change it)
3. **Deny** it (block creation)

**Kyverno intercepts pod creation**:

```
┌─────────────────────────────────────────┐
│  kubectl apply -f deployment.yaml       │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│  Kubernetes API Server                  │
│  "Someone wants to create a pod..."     │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│  Kyverno Admission Webhook              │
│  "Let me check the policies..."         │
│                                         │
│  Policy 1: Check image uses digest ✓   │
│  Policy 2: Verify Cosign signature ✓   │
│  Policy 3: Verify SLSA provenance ✓    │
│                                         │
│  All passed? → ALLOW                    │
│  Any failed?  → DENY                    │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│  Pod Created (or Denied)                │
└─────────────────────────────────────────┘
```

**Why we use it**:
- Enforces security policies automatically
- No manual verification needed
- Blocks non-compliant deployments
- Provides audit trail

---

### 6. Rekor (Transparency Log)

**What is it?**

Rekor is a **public transparency log** (like a blockchain) that records all signatures.

**Why does it exist?**

Problem: With keyless signing, how do you prove a signature existed at a certain time?

Solution: Log it publicly in Rekor.

**What gets logged**:
- Image signature
- Timestamp
- Identity that signed it
- Proof it happened

**Benefits**:
- **Tamper-proof**: Can't change history
- **Auditable**: Anyone can verify
- **Timestamped**: Proves when signing happened

**Analogy**:
- Like a notary public that witnesses and records signatures
- Public ledger that everyone can audit

---

## The Big Picture: How Everything Fits Together

Let's see the complete flow from code to running pod:

```
┌──────────────────────────────────────────────────────────────────┐
│                         1. CODE PUSH                              │
│                                                                   │
│  Developer: git push origin main                                 │
│  GitHub: Triggers workflow                                       │
└────────────────────────────┬─────────────────────────────────────┘
                             │
                             ▼
┌──────────────────────────────────────────────────────────────────┐
│                    2. BUILD PHASE (CI)                            │
│                                                                   │
│  GitHub Actions (self-hosted runner):                            │
│    ├─ Checkout code                                              │
│    ├─ Build container image with Docker                          │
│    ├─ Push to GHCR → Get digest (sha256:abc123...)              │
│    └─ Output: IMAGE_DIGEST                                       │
│                                                                   │
│  Result: ghcr.io/pecatap/python-slsa-web@sha256:abc123          │
└────────────────────────────┬─────────────────────────────────────┘
                             │
                             ▼
┌──────────────────────────────────────────────────────────────────┐
│                    3. SIGNING PHASE (CI)                          │
│                                                                   │
│  Cosign (running in GitHub Actions):                            │
│    ├─ GitHub Actions generates OIDC token (identity)            │
│    ├─ Cosign signs image with this identity                     │
│    ├─ Signature stored in GHCR as OCI artifact                  │
│    └─ Signature logged in Rekor transparency log                │
│                                                                   │
│  Identity: "workflow slsa-l3.yml in PecataP/K8S-SLSA"           │
└────────────────────────────┬─────────────────────────────────────┘
                             │
                             ▼
┌──────────────────────────────────────────────────────────────────┐
│                  4. PROVENANCE PHASE (CI)                         │
│                                                                   │
│  slsa-github-generator (separate isolated job):                  │
│    ├─ Receives image digest from previous job                   │
│    ├─ Inspects GitHub Actions context (repo, commit, etc.)      │
│    ├─ Generates SLSA L3 provenance document                     │
│    ├─ Signs provenance with generator's identity                │
│    └─ Attaches provenance to image in GHCR                      │
│                                                                   │
│  Provenance contains: builder, materials, buildType, etc.       │
└────────────────────────────┬─────────────────────────────────────┘
                             │
                             ▼
┌──────────────────────────────────────────────────────────────────┐
│                     5. VERIFICATION PHASE (CI)                    │
│                                                                   │
│  CI runs verification (optional but recommended):                │
│    ├─ cosign verify → Check signature is valid                  │
│    ├─ slsa-verifier → Check provenance is L3                    │
│    └─ Both pass → Ready to deploy                               │
└────────────────────────────┬─────────────────────────────────────┘
                             │
                             ▼
┌──────────────────────────────────────────────────────────────────┐
│            6. REGISTRY (GHCR - GitHub Container Registry)         │
│                                                                   │
│  Image stored with attachments:                                  │
│  ├─ Image layers (sha256:abc123)                                │
│  ├─ Cosign signature (OCI artifact)                             │
│  ├─ SLSA provenance (OCI attestation)                           │
│  └─ SBOM (OCI attestation)                                      │
│                                                                   │
│  All linked by digest: @sha256:abc123                           │
└────────────────────────────┬─────────────────────────────────────┘
                             │
                             │ Deployment time
                             │
                             ▼
┌──────────────────────────────────────────────────────────────────┐
│              7. DEPLOYMENT REQUEST (Kubernetes)                   │
│                                                                   │
│  kubectl apply -f deployment.yaml                                │
│                                                                   │
│  Deployment specifies:                                           │
│    image: ghcr.io/pecatap/python-slsa-web@sha256:abc123        │
│           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                 │
│           Using digest (immutable reference)                     │
└────────────────────────────┬─────────────────────────────────────┘
                             │
                             ▼
┌──────────────────────────────────────────────────────────────────┐
│              8. KYVERNO POLICY CHECK (Admission)                  │
│                                                                   │
│  Kyverno intercepts pod creation request...                      │
│                                                                   │
│  ┌─────────────────────────────────────────────────────┐        │
│  │ Policy 1: require-image-digest                      │        │
│  │   Check: Does image use @sha256:...?               │        │
│  │   Result: ✅ YES                                     │        │
│  └─────────────────────────────────────────────────────┘        │
│                                                                   │
│  ┌─────────────────────────────────────────────────────┐        │
│  │ Policy 2: verify-image-signature                    │        │
│  │   1. Pull signature from GHCR                       │        │
│  │   2. Verify it's signed by authorized workflow      │        │
│  │   3. Check signature in Rekor log                   │        │
│  │   Result: ✅ VALID                                   │        │
│  └─────────────────────────────────────────────────────┘        │
│                                                                   │
│  ┌─────────────────────────────────────────────────────┐        │
│  │ Policy 3: verify-slsa-provenance                    │        │
│  │   1. Pull provenance attestation from GHCR          │        │
│  │   2. Verify it's signed by slsa-github-generator    │        │
│  │   3. Check builder.id matches expected              │        │
│  │   4. Verify buildType is correct                    │        │
│  │   Result: ✅ VALID L3 PROVENANCE                     │        │
│  └─────────────────────────────────────────────────────┘        │
│                                                                   │
│  All policies passed? → ALLOW POD CREATION                       │
└────────────────────────────┬─────────────────────────────────────┘
                             │
                             ▼
┌──────────────────────────────────────────────────────────────────┐
│                    9. POD RUNNING                                 │
│                                                                   │
│  ✅ Pod is created                                                │
│  ✅ Kubernetes pulls image from GHCR                              │
│  ✅ Container starts running                                      │
│                                                                   │
│  You now have PROOF that:                                        │
│    - Image was built from YOUR code                             │
│    - Build happened in isolated environment                      │
│    - Image is exactly what was built (digest)                   │
│    - Image is signed by your authorized workflow                │
│    - Image has non-falsifiable provenance                       │
└──────────────────────────────────────────────────────────────────┘
```

---

## Deep Dive: Each Component

### Component 1: GitHub Actions Workflow

**Location**: `.github/workflows/slsa-l3.yml`

**Purpose**: Orchestrates the entire build, sign, and provenance generation process.

**Structure**:

The workflow has 4 jobs that run in sequence:

```
job 1: build-and-push
   │
   │ (outputs: image-digest)
   │
   ▼
job 2: provenance ────┐
   │                   │
   │                   │ (both wait for each other)
   │                   │
   ▼                   │
job 3: verify ◄────────┘
   │
   │
   ▼
job 4: summary
```

#### Job 1: build-and-push

**What it does**:
1. Checks out your code
2. Sets up Docker Buildx (build tool)
3. Logs into GHCR (registry)
4. Builds container image
5. Pushes image to GHCR
6. **Signs image with Cosign**
7. Outputs the digest for next jobs

**Key sections explained**:

```yaml
permissions:
  id-token: write  # ← Needed for OIDC keyless signing
  packages: write  # ← Needed to push to GHCR
```

- `id-token: write`: Allows GitHub Actions to generate an OIDC token
- This token is the "identity" Cosign uses to sign

```yaml
- name: Build and push container image
  uses: docker/build-push-action@v6
  with:
    provenance: false  # ← We turn OFF docker's provenance
    # Why? Because slsa-github-generator will generate better L3 provenance
```

```yaml
- name: Sign container image with Cosign
  run: |
    cosign sign --yes ${images}
```

- `--yes`: Skip confirmation (for automation)
- No private key! Uses OIDC token from GitHub Actions
- Signature automatically logged in Rekor

#### Job 2: provenance

**What it does**:
Calls the SLSA team's reusable workflow to generate L3 provenance

**Key parts**:

```yaml
uses: slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@v2.0.0
```

- This is a **reusable workflow** from another repository
- You don't control what it does inside
- It generates provenance independently
- Signs the provenance with its own identity

```yaml
with:
  image: ${{ needs.build-and-push.outputs.image-name }}
  digest: ${{ needs.build-and-push.outputs.image-digest }}
```

- You tell it: "Here's my image and digest"
- It generates provenance about that image
- It verifies the digest matches what's in the registry

#### Job 3: verify

**What it does**:
Verifies that signing and provenance generation worked correctly

**Why do this in CI?**

- Catch problems early
- Ensure everything is correct before deployment
- Provides confidence in the process

**Key commands**:

```bash
# Verify Cosign signature
cosign verify \
  --certificate-identity-regexp="https://github.com/PecataP/K8S-SLSA/.*" \
  --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
  "${IMAGE}@${DIGEST}"
```

- `certificate-identity-regexp`: The workflow identity must match
- `certificate-oidc-issuer`: Must be GitHub Actions
- This prevents someone else from signing and pretending to be you

```bash
# Verify SLSA provenance
slsa-verifier verify-image \
  --source-uri github.com/PecataP/K8S-SLSA \
  --source-branch main \
  "${IMAGE}@${DIGEST}"
```

- Checks provenance exists
- Verifies it's signed by slsa-github-generator
- Ensures it points to your repository
- Validates it's L3 compliant

#### Job 4: summary

**What it does**:
Creates a nice summary in GitHub Actions UI with deployment instructions

---

### Component 2: Kyverno Policies

**Location**: `k8s/kyverno-policies/`

We have 3 policies. Let's explain each:

#### Policy 1: require-image-digest.yaml

**Purpose**: Enforce that all images use digests, not tags

**The full policy**:

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-image-digest
spec:
  validationFailureAction: Enforce  # Block if policy fails
  background: true  # Check existing resources too
  rules:
    - name: require-image-digest
      match:
        any:
          - resources:
              kinds:
                - Pod
              namespaces:
                - demo
      validate:
        message: "Images must use digest references..."
        pattern:
          spec:
            containers:
              - image: "*@sha256:*"  # Must contain @sha256:
```

**How it works**:

1. **Match**: Apply this rule to Pods in namespace "demo"
2. **Validate**: Check that image matches pattern `*@sha256:*`
3. **Action**: If doesn't match, block (Enforce mode)

**Examples**:

```yaml
# ✅ ALLOWED
image: ghcr.io/pecatap/python-slsa-web@sha256:abc123def456...

# ❌ BLOCKED
image: ghcr.io/pecatap/python-slsa-web:latest

# ❌ BLOCKED
image: ghcr.io/pecatap/python-slsa-web:v1.0
```

**Why this is important**:

Tags can be overwritten:
```bash
# Attacker pushes malicious image
docker tag malicious-image ghcr.io/pecatap/python-slsa-web:latest
docker push ghcr.io/pecatap/python-slsa-web:latest

# Your deployment pulls :latest
# You get the malicious image!
```

Digests are immutable:
```bash
# Attacker can't change what sha256:abc123 points to
# It's cryptographically bound to the image content
```

#### Policy 2: verify-image-signature.yaml

**Purpose**: Verify images are signed with Cosign by authorized workflow

**Key parts explained**:

```yaml
spec:
  validationFailureAction: Enforce
  background: false  # Only check new pods (signature verification is slow)
  webhookTimeoutSeconds: 30  # Give enough time for verification
```

```yaml
verifyImages:
  - imageReferences:
      - "ghcr.io/pecatap/python-slsa-web*"
```

- Only verify images from your repository
- Wildcard `*` matches all tags/digests

```yaml
attestors:
  - entries:
      - keyless:
          subject: "https://github.com/PecataP/K8S-SLSA/.github/workflows/slsa-l3.yml@refs/heads/main"
          issuer: "https://token.actions.githubusercontent.com"
          rekor:
            url: https://rekor.sigstore.dev
```

**Breaking this down**:

- **keyless**: Use keyless verification (OIDC)
- **subject**: The workflow identity that signed it must match
  - Format: `https://github.com/{owner}/{repo}/.github/workflows/{workflow}@{ref}`
  - This ensures only YOUR workflow can sign images that will be accepted
- **issuer**: Must be GitHub Actions OIDC issuer
- **rekor**: Verify signature exists in transparency log

**What happens when pod is created**:

1. Kyverno intercepts pod creation
2. Sees image: `ghcr.io/pecatap/python-slsa-web@sha256:abc123`
3. Matches the imageReference pattern
4. Pulls signature from GHCR
5. Verifies signature with Cosign
6. Checks subject matches your workflow
7. Checks issuer is GitHub Actions
8. Verifies signature in Rekor log
9. If all pass → Allow
10. If any fail → Block

#### Policy 3: verify-slsa-provenance.yaml

**Purpose**: Verify SLSA L3 provenance exists and is valid

**Key parts**:

```yaml
verifyImages:
  - imageReferences:
      - "ghcr.io/pecatap/python-slsa-web*"
    attestations:
      - type: https://slsa.dev/provenance/v1
```

- `attestations`: Check for attestations (provenance) not just signatures
- `type`: Must be SLSA provenance (not just any attestation)

```yaml
attestors:
  - entries:
      - keyless:
          subject: "https://github.com/slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@refs/tags/v2.0.0"
```

- Provenance must be signed by slsa-github-generator
- This proves it's L3 (user didn't generate it)

```yaml
conditions:
  - all:
      - key: "{{ builder.id }}"
        operator: Equals
        value: "https://github.com/slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@refs/tags/v2.0.0"
```

- Check the actual builder ID in the provenance
- Must match slsa-github-generator

```yaml
      - key: "{{ buildType }}"
        operator: Equals
        value: "https://slsa.dev/container-based-build/v0.1?draft"
```

- Check the build type is container-based
- This is part of SLSA provenance spec

**What this verifies**:

1. Provenance attestation exists
2. It's signed by slsa-github-generator (not user-controlled)
3. Builder ID is correct
4. Build type is correct
5. All cryptographic signatures are valid

---

### Component 3: Deployment Manifest

**Location**: `k8s/deployment.yaml`

**Key change**:

```yaml
containers:
  - name: python-slsa-web
    image: ghcr.io/pecatap/python-slsa-web@sha256:REPLACE_WITH_ACTUAL_DIGEST
    #                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    #                                        Digest, not tag!
```

**Why this matters**:

- Kyverno policy 1 requires digests
- Ensures you deploy exactly what was built and verified
- Prevents accidental deployment of unsigned images

**How to update**:

After each CI build:

```bash
# Get digest from GitHub Actions
DIGEST=$(gh run view --log | grep "Digest:" | head -1 | awk '{print $2}')

# Update deployment
./scripts/update-deployment-digest.sh "${DIGEST}"
```

---

### Component 4: Helper Script

**Location**: `scripts/update-deployment-digest.sh`

**What it does**:
Makes updating the deployment with new digests easier

**Key features**:

1. **Validates digest format**:
```bash
if [[ ! "$DIGEST" =~ ^sha256:[a-f0-9]{64}$ ]]; then
    echo "Error: Invalid digest format"
    exit 1
fi
```

2. **Creates backup**:
```bash
cp "${DEPLOYMENT_FILE}" "${DEPLOYMENT_FILE}.backup"
```

3. **Updates image reference**:
```bash
sed -i "s|image: ${IMAGE_NAME}@sha256:[a-f0-9]*|image: ${FULL_IMAGE}|g" "${DEPLOYMENT_FILE}"
```

4. **Shows diff**:
```bash
diff -u "${DEPLOYMENT_FILE}.backup" "${DEPLOYMENT_FILE}"
```

5. **Asks for confirmation** before applying

6. **Waits for rollout**:
```bash
kubectl rollout status deployment/python-slsa-web -n demo
```

---

## Step-by-Step Flow

Let's walk through a complete example, from code change to running pod.

### Step 1: Developer Makes Code Change

```bash
# Edit app.py
vim app.py

# Commit
git add app.py
git commit -m "Add new feature"

# Push
git push origin main
```

### Step 2: GitHub Actions Triggered

GitHub sees the push and starts workflow: `.github/workflows/slsa-l3.yml`

### Step 3: Build Job Runs

```
[build-and-push job]

Checkout code ✓
  → Clones repo at commit a1b2c3d4

Set up Docker Buildx ✓
  → Prepares build environment

Login to GHCR ✓
  → Authenticates with GitHub token

Build image ✓
  → docker build -t ghcr.io/pecatap/python-slsa-web:latest .
  → Layers: [python-alpine, app.py, dependencies]

Push to GHCR ✓
  → docker push ghcr.io/pecatap/python-slsa-web:latest
  → Registry returns digest: sha256:a1b2c3d4e5f6...

Sign with Cosign ✓
  → GitHub generates OIDC token
  → Token identity: "workflow slsa-l3.yml in PecataP/K8S-SLSA at commit a1b2c3"
  → cosign sign --yes ghcr.io/pecatap/python-slsa-web@sha256:a1b2c3d4
  → Signature created and logged in Rekor
  → Signature attached to image in GHCR

Output: image-digest = sha256:a1b2c3d4e5f6...
```

### Step 4: Provenance Job Runs

```
[provenance job]

Receives digest from previous job: sha256:a1b2c3d4e5f6...

Calls slsa-github-generator ✓
  → Separate workflow in slsa-framework repo
  → Runs in isolated environment
  → Cannot be modified by user

slsa-github-generator inspects build:
  → Repository: github.com/PecataP/K8S-SLSA
  → Commit: a1b2c3d4
  → Workflow: .github/workflows/slsa-l3.yml
  → Runner: self-hosted
  → Image: ghcr.io/pecatap/python-slsa-web@sha256:a1b2c3d4e5f6...

Generates provenance document ✓
  → Contains: builder, materials, buildType, metadata
  → Signs with generator's identity
  → Attaches to image in GHCR as attestation

Result: L3 provenance attached to image
```

### Step 5: Verify Job Runs

```
[verify job]

Install tools ✓
  → cosign
  → slsa-verifier

Verify signature with Cosign ✓
  → cosign verify --certificate-identity-regexp=... --certificate-oidc-issuer=...
  → Checks signature is valid
  → Checks identity matches workflow
  → Checks signature in Rekor
  → Result: ✅ VALID

Verify provenance with slsa-verifier ✓
  → slsa-verifier verify-image --source-uri github.com/PecataP/K8S-SLSA
  → Checks provenance exists
  → Checks it's L3 compliant
  → Checks builder is slsa-github-generator
  → Checks source matches
  → Result: ✅ VALID L3 PROVENANCE

All verifications passed ✓
```

### Step 6: Summary Job Runs

```
[summary job]

Generates GitHub Actions summary ✓
  → Shows image name, digest, commit
  → Displays SLSA compliance table
  → Provides deployment commands
  → Shows verification commands
```

### Step 7: CI Complete

At this point in GHCR you have:

```
ghcr.io/pecatap/python-slsa-web:latest
  │
  ├─ Manifest (image layers) @ sha256:a1b2c3d4e5f6...
  │
  ├─ Cosign Signature (OCI artifact)
  │    └─ Signed by: workflow slsa-l3.yml
  │    └─ Logged in: Rekor
  │
  ├─ SLSA Provenance (OCI attestation)
  │    └─ Generated by: slsa-github-generator
  │    └─ Builder: slsa-framework/slsa-github-generator
  │    └─ Materials: [commit a1b2c3d4, base images, ...]
  │
  └─ SBOM (OCI attestation)
       └─ Software Bill of Materials
```

### Step 8: Update Deployment

```bash
# Get digest
DIGEST="sha256:a1b2c3d4e5f6..."

# Run update script
./scripts/update-deployment-digest.sh "${DIGEST}"

# Script updates k8s/deployment.yaml:
# FROM: image: ghcr.io/pecatap/python-slsa-web@sha256:OLD
# TO:   image: ghcr.io/pecatap/python-slsa-web@sha256:a1b2c3d4e5f6...
```

### Step 9: Apply Deployment

```bash
kubectl apply -f k8s/deployment.yaml
```

### Step 10: Kyverno Intercepts Request

```
[Kubernetes API Server]
Receives pod creation request...

[Kyverno Admission Webhook]
Intercepting pod creation...

Checking policy 1: require-image-digest
  → Image: ghcr.io/pecatap/python-slsa-web@sha256:a1b2c3d4e5f6...
  → Contains @sha256:? YES ✓
  → Result: PASS

Checking policy 2: verify-image-signature
  → Pulling signature from GHCR...
  → Signature found ✓
  → Verifying with Cosign...
  → Identity: https://github.com/PecataP/K8S-SLSA/.github/workflows/slsa-l3.yml@refs/heads/main
  → Matches expected? YES ✓
  → Issuer: https://token.actions.githubusercontent.com
  → Matches expected? YES ✓
  → Checking Rekor log...
  → Signature in log? YES ✓
  → Result: PASS

Checking policy 3: verify-slsa-provenance
  → Pulling provenance attestation from GHCR...
  → Attestation found ✓
  → Type: https://slsa.dev/provenance/v1 ✓
  → Verifying signature...
  → Signed by: slsa-github-generator ✓
  → Checking builder.id...
  → Builder: https://github.com/slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@refs/tags/v2.0.0
  → Matches expected? YES ✓
  → Checking buildType...
  → BuildType: https://slsa.dev/container-based-build/v0.1?draft
  → Matches expected? YES ✓
  → Result: PASS

All policies passed! → ALLOW pod creation
```

### Step 11: Pod Runs

```
[Kubernetes]
Creating pod...
Pulling image from GHCR...
Starting container...

Pod is now RUNNING ✓
```

### Verification Complete

You now have **cryptographic proof** that:

1. ✅ The running code came from commit `a1b2c3d4`
2. ✅ It was built in GitHub Actions
3. ✅ The build happened in an isolated environment
4. ✅ The image is signed by your authorized workflow
5. ✅ The provenance is non-falsifiable (L3)
6. ✅ Nobody tampered with the image
7. ✅ The deployment uses immutable reference (digest)

---

## Common Questions

### Q1: Why keyless signing? Why not use a private key?

**Answer**:

With keys:
- ❌ Generate key pair
- ❌ Store private key securely (where? how?)
- ❌ Rotate keys periodically
- ❌ Revoke compromised keys
- ❌ Access control (who can use key?)

With keyless (OIDC):
- ✅ No keys to manage
- ✅ Identity is the workflow itself
- ✅ Automatic rotation (tokens are short-lived)
- ✅ Automatically revoked after use
- ✅ Access control via GitHub permissions

**How it works**:

GitHub Actions generates a short-lived OIDC token that says:
```json
{
  "iss": "https://token.actions.githubusercontent.com",
  "sub": "repo:PecataP/K8S-SLSA:ref:refs/heads/main",
  "aud": "sigstore",
  "exp": 1234567890
}
```

Cosign uses this token to sign. The signature contains this identity. When verifying, you check: "Was this signed by my workflow?"

### Q2: What if I want to deploy manually without CI?

**Answer**:

You can't with L3, and that's the point!

SLSA L3 requires:
- Provenance generated by a trusted service (slsa-github-generator)
- Signature from authorized identity (GitHub workflow)

Manual builds don't meet these requirements because YOU control them (you could lie about provenance).

If you need manual builds:
- Use L2 (docker build with provenance: true)
- Or create a CI workflow you can trigger manually
- Or create a "manual build" workflow with appropriate policies

### Q3: What happens if someone compromises the registry (GHCR)?

**Answer**:

They still can't fool your cluster!

Scenario: Attacker replaces your image in GHCR

```
Attacker:
  docker tag malicious-image ghcr.io/pecatap/python-slsa-web:latest
  docker push ghcr.io/pecatap/python-slsa-web:latest
```

**Why this fails**:

1. **Digest changes**: New image has different digest
   - Your deployment references old digest
   - Won't pull the malicious image

2. **Signature missing**: Attacker's image isn't signed
   - Kyverno verifies signature
   - Blocks unsigned image

3. **Even if attacker signs**: Their workflow identity won't match
   - Signature identity would be attacker's workflow
   - Kyverno checks identity matches YOUR workflow
   - Blocks wrong identity

4. **Even if they steal workflow token**: Tokens are short-lived
   - OIDC tokens expire in minutes
   - Logged in Rekor with timestamp
   - Can detect suspicious activity

### Q4: Why do we need BOTH Cosign signatures AND SLSA provenance?

**Answer**:

They serve different purposes:

**Cosign Signature**:
- **What**: Cryptographic signature on the image
- **Proves**: Image came from authorized workflow
- **Checks**: Identity (who signed)
- **Fast**: Quick to verify

**SLSA Provenance**:
- **What**: Detailed metadata about the build
- **Proves**: HOW the image was built
- **Checks**: Builder, materials, process, environment
- **Comprehensive**: Full supply chain info

**Example**:

Cosign says: "This image was signed by PecataP/K8S-SLSA workflow ✓"

Provenance says:
- "Built from commit a1b2c3d4 ✓"
- "Built by slsa-github-generator ✓"
- "Used these materials: [python:3.11-alpine, code, ...] ✓"
- "Build happened at 10:00am on 2024-01-15 ✓"
- "Builder ran in isolated environment ✓"

Together they provide defense in depth.

### Q5: What if CI is compromised?

**Answer**:

SLSA L3 provides significant protection:

**If attacker compromises your workflow**:
- ❌ Can modify build steps
- ❌ Can inject malicious code
- ✅ BUT provenance will show the malicious changes
- ✅ Audit trail in Rekor

**If attacker compromises slsa-github-generator**:
- Very difficult (maintained by SLSA team)
- Heavily audited
- Transparent (all changes public)
- If compromised, affects everyone (would be detected)

**If attacker compromises GitHub Actions itself**:
- Out of scope for L3
- Would need L4 (two-person review, hermetic builds)
- Or use different build platform

**Mitigation**:
- Review PRs carefully
- Monitor Rekor logs for unexpected signatures
- Use branch protection (require reviews)
- Enable GitHub audit logs
- Consider L4 for higher security

### Q6: Can I use this with public images like nginx?

**Answer**:

No, and you shouldn't try.

**Why**:

Public images like `nginx:latest`:
- Not built by YOUR workflow
- Don't have YOUR signature
- Don't have SLSA provenance from slsa-github-generator
- Kyverno would block them

**Solution**:

Option 1: Create your own base image
```dockerfile
# Build your own nginx with your toolchain
FROM nginx:1.25
COPY my-config.conf /etc/nginx/
```

Then build, sign, and deploy with L3.

Option 2: Exclude system namespaces
```yaml
# In Kyverno policy
match:
  resources:
    namespaces:
      - demo  # Only enforce in your namespaces
exclude:
  resources:
    namespaces:
      - kube-system  # Allow system images
```

Option 3: Verify public image signatures
Some projects (like Sigstore, Distroless) sign their images. Configure Kyverno to verify THEIR signatures.

### Q7: What's the performance impact?

**Answer**:

**CI/CD** (small impact):
- Cosign signing: +10-30 seconds
- Provenance generation: +30-60 seconds
- Verification: +10-20 seconds
- Total: +50-110 seconds per build

**Deployment** (moderate impact):
- Kyverno verification: +5-15 seconds per pod
- Signature verification: Network call to GHCR + Rekor
- Provenance verification: Network call to GHCR
- First deployment slower (downloads attestations)
- Cached afterwards

**Mitigation**:
- Increase webhook timeout if needed
- Use fast registry (GHCR is fast)
- Cache attestations in cluster
- Consider policy report mode (async verification)

**Runtime** (no impact):
- Once pod is running, no overhead
- Verification only at admission time

### Q8: Can I test this locally?

**Answer**:

Partially, yes!

**What you can test locally**:

1. **Build image**:
```bash
docker build -t test-image .
```

2. **Sign with Cosign** (requires setup):
```bash
# Generate test keys (not for production!)
cosign generate-key-pair

# Sign
cosign sign --key cosign.key test-image
```

3. **Verify signature**:
```bash
cosign verify --key cosign.pub test-image
```

**What you CAN'T test locally**:

- **OIDC keyless signing**: Requires GitHub Actions OIDC token
- **slsa-github-generator**: Runs only in GitHub Actions
- **L3 provenance**: Requires slsa-github-generator
- **Kyverno policies**: Requires Kubernetes cluster

**Recommendation**:

Use a test namespace in your cluster:
```bash
kubectl create namespace test-slsa
```

Apply policies in Audit mode to test namespace first.

---

## Summary

Let's recap the key points:

### What We Built

1. **CI/CD Pipeline** that:
   - Builds container images
   - Signs with Cosign (keyless OIDC)
   - Generates SLSA L3 provenance
   - Verifies everything worked

2. **Kubernetes Policies** that:
   - Require digest references
   - Verify Cosign signatures
   - Verify SLSA L3 provenance
   - Block non-compliant deployments

3. **Deployment Process** that:
   - Uses immutable digests
   - Ensures only verified images run
   - Provides audit trail

### SLSA L3 Guarantees

✅ **Provenance**: Detailed metadata about build
✅ **Non-falsifiable**: Generated by trusted service
✅ **Hardened builds**: Isolated environment
✅ **Cryptographic signing**: Signatures on images
✅ **Transparency**: Logged in Rekor
✅ **Policy enforcement**: Automated verification

### Key Technologies

- **Cosign**: Sign and verify container images
- **slsa-github-generator**: Generate L3 provenance
- **Kyverno**: Enforce policies in Kubernetes
- **Rekor**: Transparency log for signatures
- **OIDC**: Keyless identity for signing
- **Digests**: Immutable image references

### What This Protects Against

✅ Compromised dependencies
✅ Malicious code injection
✅ Build process tampering
✅ Image substitution attacks
✅ Tag mutation attacks
✅ Unauthorized deployments
✅ Rogue insiders

### What This Doesn't Protect Against

❌ Vulnerabilities in your code (use scanning)
❌ Runtime attacks (use runtime security)
❌ GitHub Actions compromise (need L4)
❌ Zero-day exploits (need monitoring)

---

## Next Steps

1. **Apply policies in Audit mode**
2. **Run first build**
3. **Verify signatures and provenance**
4. **Deploy with digest**
5. **Switch to Enforce mode**
6. **Monitor and audit**

---

## Additional Resources

- [SLSA Specification](https://slsa.dev/)
- [Sigstore Documentation](https://docs.sigstore.dev/)
- [Cosign GitHub](https://github.com/sigstore/cosign)
- [slsa-github-generator](https://github.com/slsa-framework/slsa-github-generator)
- [Kyverno Documentation](https://kyverno.io/docs/)
- [OIDC in GitHub Actions](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect)

---

**Congratulations!** You now understand SLSA L3 from the ground up. You know what each component does, why it's needed, and how they work together to secure your software supply chain.
